pico-8 cartridge // http://www.pico-8.com
version 16
__lua__
function _init()
	player=actor:new({x=8,y=15})
end

--function _update() dt=1/30; update(dt) end
function _update60() dt=1/60; update(dt) end

function update(dt)
	jk_update()
	
	player.ddy=2
	
	local ix,iy=0,0
	if (btn(0)) ix-=1
	if (btn(1)) ix+=1
	if (btn(2)) iy-=1
	if (btn(3)) iy+=1
	
	local bx,bo=btnp(4),btnp(5)
	
	player.inp.x=ix
	player.inp.y=iy
	player.inp.bx=bx
	player.inp.bo=bo

	player:control(dt)
	player:move(dt)
	
	watch("pos:"..player.x..","..player.y)
	watch("vel:"..player.dx/dt..","..player.dy/dt)
end

function _draw()
	cls()
	
	map(0,0,0,0,16,16)
	
	local sx,sy=w2s(player.x,player.y)
	spr(1,sx-4,sy-8,1,1,player.face<0)
	pset(sx,sy,8)
	
	draw_log()
	draw_watch()
end
-->8
-- actors

-- actor flags
af={
	grounded=shl(1,0),
}

actor={
	x=0,y=0,					-- position
	dx=0,dy=0,			-- velocity
	ddx=0,ddy=0,	-- acceleration
	w=0.3,h=0.5, -- half width/height
	face=1,
	flags=0,
	jumps=0,
	mass=1,
	drag=0,
	t_air=0,
	k_coldst=0.3, -- collision check distance
	k_scndst=0.1, -- scan distance while searching for contact point
	k_bounce_wall=0,
	k_bounce_floor=0,
	k_jump_force=24,
	k_max_move=8,
	k_jump_forgive_t=5/60
}

function actor:premove()
end

function actor:postmove()
end

function actor:jump(dt)
	local f=min(self.k_jump_force*dt,1)
	self.dy=-f
end

function actor:force(fx,fy)
	local m=max(self.mass,0.01)
	self.dx+=fx/m*dt
	self.dy+=fy/m*dt
end

function actor:friction(fx,fy)
	fx=mid(fx,0,1)
	fy=mid(fy,0,1)
	self.dx=self.dx*(1-fx)
	self.dy=self.dy*(1-fy)
end

function actor:linfric(fx,fy)
	self.dx=moveto(self.dx,0,fx*dt)
	self.dy=moveto(self.dy,0,fy*dt)
end

function actor:control(dt)
	local accel=480/2*dt
	if not self:getf(af.grounded) then
		accel=shr(accel,1)
	end
	
	if self.inp.x<0 then
		self.dx-=accel*dt
		self.face=-1
	elseif self.inp.x>0 then
		self.dx+=accel*dt
		self.face=1
	else
		self.dx=moveto(self.dx,0,1*dt)
	end

	local stand=self:getf(af.grounded)

	if stand then	
		self.jumps=0
	end
	
	local canjump=stand
		or self.jumps<0
		or (not stand
						and self.t_air<self.k_jump_forgive_t)
		
	if self.inp.bx and canjump then
		self:jump(dt)
		--player:force(0,-18)
		self.jumps+=1
	end
end

function actor:move(dt)
	self:setf(af.grounded,false)
	
	self.dx+=self.ddx*dt
	self.dy+=self.ddy*dt
	
	local max_x,max_y=
		self.k_max_move*dt,30*dt
	self.dx=mid(self.dx,-max_x,max_x)
	self.dy=mid(self.dy,-max_y,max_y)
	
	-- x movement
	local nx=self.x+
		self.dx+sgn(self.dx)*self.k_coldst
		
	if not solid(nx,self.y-0.5) then
		-- no contact, move normally
		self.x+=self.dx
	else
		-- hit solid
		-- find contact point
		while not solid(
			self.x+sgn(self.dx)*self.k_coldst,
			self.y-0.5)
		do
			self.x+=sgn(self.dx)*self.k_scndst
		end
		
		-- bounce
		self.dx*=-self.k_bounce_wall
	end

	-- y movement	
	local left,right=
		self.x-0.2,self.x+0.2

	if self.dy<0 then
		-- going up
		if solid(left,self.y+self.dy-1) or
			solid(right,self.y+self.dy-1)
		then
			-- hit ceiling
			self.dy=0
			
			-- search contact point
			while not solid(left,self.y-1)
				and not solid(right,self.y-1)
			do
				self.y-=0.01
			end
		else
			self.y+=self.dy
		end
	else
		-- going down
		if solid(left,self.y+self.dy)
			or solid(right,self.y+self.dy)
		then
			-- bounce
			if self.k_bounce_floor>0 and
				self.dy>0.2
			then
				self.dy*=-self.k_bounce_floor
			else
				self:setf(af.grounded,true)
				self.dy=0
			end
			
			-- snap down
			while not solid(left,self.y)
				and not solid(right,self.y)
			do
				self.y+=0.05
			end

			-- pop up
			while solid(left,self.y-0.1)
			do
				self.y-=0.05
			end
			while solid(right,self.y-0.1)
			do
				self.y-=0.05
			end
		else
			self.y+=self.dy
		end
	end
	
	if self:getf(af.grounded) then
		self.t_air=0
	else
		self.t_air+=dt
	end
end

function actor:new(p)
	self.__index=self
	p=p or {}
	p.inp={x=0,y=0,bx=false,by=false}
	return setmetatable(p,self)
end

function actor:setf(f,v)
	if v then
		self.flags=bor(self.flags,f)
	else
		self.flags=band(self.flags,
			bnot(f))
	end
	return self.flags
end

function actor:getf(f)
	return band(self.flags,f)~=0
end
-->8
-- utils

_sgn=sgn
function sgn(v)
	if (v==0) return 0
	return _sgn(v)
end

function moveto(a,b,d)
	if abs(b-a)<=d then
		return b
	else
		return a+sgn(b-a)*d
	end
end

_watches={}

function watch(msg,col)
	add(_watches,{msg=tostr(msg),
		col=col or 12})
end

function draw_watch(col)
	col=col or 12
	local n=#_watches
	for i=0,n-1 do
		local w=_watches[i+1]
		print(w.msg,0,i*6,w.col)
	end
end

_logs={}

function log(msg,col)
	add(_logs,{msg=tostr(msg),col=col or 6})
	local n=#_logs
	if n>20 then
		for i=2,n do
			_logs[i-1]=_logs[i]
		end
		_logs[n]=nil
	end
end

function draw_log()
	local n=#_logs
	for i=1,n do
		local l=_logs[i]
		print(l.msg,127-#l.msg*4,(i-1)*6,l.col)
	end
end

_jk_btns={}
for i=0,5 do
	_jk_btns[i]={
		last={},
		curr={},
	}
end

function jk_update()
	_watches={}

	for p=0,5 do
		local pl=_jk_btns[p]
		for b=0,5 do
			pl.last[b]=pl.curr[b] or false
			pl.curr[b]=btn(b,p)
		end
	end
end

_btnp=btnp
function btnp(b,p)
	p=p or 0
	local pl=_jk_btns[p]
	return pl.curr[b] and not pl.last[b]
end

function btnr(b,p)
	p=p or 0
	local pl=_jk_btns[p]
	return not pl.curr[b] and pl.last[b]
end

-->8
-- physics

function w2s(wx,wy)
	-- todo: camera
	return wx*8,wy*8
end

function solid(wx,wy)
	-- todo: other things
	return map_solid(wx,wy)
end

-- is world coord: wx,wy solid
-- 1 world unit == 8 pixels
function map_solid(wx,wy)
	if wx<0 or wx>127 or
		wy<0 or wy>127 then
		return false
	end
	val=mget(wx,wy)
	return fget(val,0)
end

__gfx__
00000000099999905555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000009aaaaa05555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0070070009aa1a105555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0007700009aaaaa05555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0007700099aaaaa95555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0070070099aaaaa95555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000099aaaaa95555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000099999905555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
__gff__
0000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
__map__
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0202020000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000020000000000000202020200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000200000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000002020200000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000020200000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000002000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0202020202020202020202020202020200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
